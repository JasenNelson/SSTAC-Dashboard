/**
 * Regulatory Review Engine API
 *
 * POST /api/regulatory-review/run-engine
 * Runs the CSAP evaluation engine on a submission's extraction data.
 *
 * Supports:
 * - Using existing extraction files in the system
 * - Uploading new extraction JSON files
 */

import { NextRequest, NextResponse } from 'next/server';
import { spawn } from 'child_process';
import { writeFile, mkdir, readFile, unlink } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';

// Base paths for the regulatory review engine
const ENGINE_BASE_PATH = 'F:/Regulatory-Review/engine';
const EXTRACTIONS_PATH = 'F:/Regulatory-Review/1_Active_Reviews/Teck_Trail-WARP/1_Extractions/2025_AIP_Application';
const OUTPUT_PATH = 'F:/Regulatory-Review/1_Active_Reviews/Teck_Trail-WARP/2_Evaluation_Output';
const TEMP_UPLOAD_PATH = 'F:/Regulatory-Review/engine/data/temp_uploads';

// Types matching the engine output
interface EvidenceItem {
  spec_id: string;
  spec_description: string;
  evidence_type: string;
  source_file: string;
  location: string;
  page_reference: string;
  excerpt: string;
  confidence: string;
  match_reasons: string[];
}

interface AssessmentResult {
  csap_id: string;
  csap_text: string;
  section: string | null;
  sheet: string | null;
  item_number: number | null;
  result: string;
  confidence: string;
  discretion_tier: string;
  evidence_coverage: number;
  regulatory_authority: string | null;
  linked_policies: string[];
  reviewer_notes: string | null;
  action_required: string | null;
  evidence_found: EvidenceItem[];
  keywords_matched: string[];
  sections_searched: number;
}

interface EvaluationResult {
  evaluation_id: string;
  submission_id: string;
  site_id: string;
  submission_type: string;
  evaluation_started: string;
  evaluation_completed: string;
  checklist_source: string;
  total_checklist_items: number;
  summary: {
    total_items: number;
    pass_count: number;
    partial_count: number;
    fail_count: number;
    na_count: number;
    requires_judgment_count: number;
    tier1_count: number;
    tier2_count: number;
    tier3_count: number;
    overall_coverage: number;
  };
  overall_recommendation: string;
  requires_human_review: boolean;
  assessments: AssessmentResult[];
}

/**
 * Run the Python evaluation engine
 */
async function runEvaluationEngine(
  submissionId: string,
  extractionPath: string
): Promise<EvaluationResult> {
  return new Promise((resolve, reject) => {
    const scriptPath = path.join(ENGINE_BASE_PATH, 'scripts', 'orchestrators', 'run_ralph_evaluation.py');

    // Check if script exists
    if (!existsSync(scriptPath)) {
      reject(new Error(`Evaluation script not found: ${scriptPath}`));
      return;
    }

    // Environment variables for the Python script
    const env = {
      ...process.env,
      EXTRACTION_PATH: extractionPath,
      OUTPUT_PATH: OUTPUT_PATH,
      SUBMISSION_ID: submissionId,
    };

    // Spawn Python process
    const pythonProcess = spawn('python', [scriptPath], {
      cwd: ENGINE_BASE_PATH,
      env,
      shell: true,
    });

    let stdout = '';
    let stderr = '';

    pythonProcess.stdout.on('data', (data) => {
      stdout += data.toString();
      console.log('[Engine]', data.toString());
    });

    pythonProcess.stderr.on('data', (data) => {
      stderr += data.toString();
      console.error('[Engine Error]', data.toString());
    });

    pythonProcess.on('close', async (code) => {
      if (code !== 0) {
        reject(new Error(`Engine exited with code ${code}: ${stderr || stdout}`));
        return;
      }

      try {
        // Find the most recent output JSON file
        const outputFiles = await findOutputFiles(OUTPUT_PATH, submissionId);
        if (outputFiles.length === 0) {
          reject(new Error('No output file generated by engine'));
          return;
        }

        // Read the result JSON
        const resultPath = outputFiles[0];
        const resultContent = await readFile(resultPath, 'utf-8');
        const result: EvaluationResult = JSON.parse(resultContent);

        resolve(result);
      } catch (error) {
        reject(new Error(`Failed to read engine output: ${error}`));
      }
    });

    pythonProcess.on('error', (error) => {
      reject(new Error(`Failed to start engine: ${error.message}`));
    });
  });
}

/**
 * Find output files from engine run
 */
async function findOutputFiles(outputDir: string, submissionId: string): Promise<string[]> {
  const { readdir, stat } = await import('fs/promises');

  try {
    const files = await readdir(outputDir);
    const jsonFiles = files
      .filter((f) => f.endsWith('.json') && (f.includes('EvalResult') || f.includes('evaluation_results')))
      .map((f) => path.join(outputDir, f));

    // Sort by modification time (most recent first)
    const filesWithStats = await Promise.all(
      jsonFiles.map(async (f) => ({
        path: f,
        mtime: (await stat(f)).mtime.getTime(),
      }))
    );

    filesWithStats.sort((a, b) => b.mtime - a.mtime);
    return filesWithStats.map((f) => f.path);
  } catch {
    return [];
  }
}

/**
 * Save uploaded files to temp directory
 */
async function saveUploadedFiles(files: File[]): Promise<string> {
  const timestamp = Date.now();
  const uploadDir = path.join(TEMP_UPLOAD_PATH, `upload_${timestamp}`);

  // Create upload directory
  await mkdir(uploadDir, { recursive: true });

  // Save each file
  for (const file of files) {
    const buffer = Buffer.from(await file.arrayBuffer());
    const filePath = path.join(uploadDir, file.name);
    await writeFile(filePath, buffer);
  }

  return uploadDir;
}

/**
 * Clean up temporary upload directory
 */
async function cleanupUploadDir(uploadDir: string): Promise<void> {
  const { readdir, rm } = await import('fs/promises');

  try {
    const files = await readdir(uploadDir);
    for (const file of files) {
      await unlink(path.join(uploadDir, file));
    }
    await rm(uploadDir, { recursive: true });
  } catch (error) {
    console.error('Failed to cleanup upload dir:', error);
  }
}

/**
 * Import evaluation results into the dashboard database
 */
async function importResultsToDatabase(result: EvaluationResult): Promise<{
  submissionCreated: boolean;
  assessmentsImported: number;
}> {
  // Dynamic import to avoid issues with better-sqlite3 in API routes
  const { getDatabase } = await import('@/lib/sqlite/client');

  const db = getDatabase();
  let submissionCreated = false;
  let assessmentsImported = 0;

  // First, delete existing data for this submission (to allow re-runs)
  // Note: Delete by submission_id column (not id) since id may be a UUID
  const existingSubmission = db.prepare('SELECT id FROM submissions WHERE submission_id = ?').get(result.submission_id) as { id: string } | undefined;
  if (existingSubmission) {
    db.prepare('DELETE FROM judgments WHERE assessment_id IN (SELECT id FROM assessments WHERE submission_id = ?)').run(existingSubmission.id);
    db.prepare('DELETE FROM assessments WHERE submission_id = ?').run(existingSubmission.id);
    db.prepare('DELETE FROM submissions WHERE id = ?').run(existingSubmission.id);
  }

  // Create submission
  const insertSubmission = db.prepare(`
    INSERT INTO submissions (
      id, submission_id, site_id, submission_type, checklist_source,
      total_items, evaluation_started, evaluation_completed,
      overall_recommendation, requires_human_review,
      pass_count, partial_count, fail_count, requires_judgment_count,
      tier1_count, tier2_count, tier3_count, overall_coverage
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);

  insertSubmission.run(
    result.submission_id,
    result.submission_id,
    result.site_id,
    result.submission_type,
    result.checklist_source,
    result.total_checklist_items,
    result.evaluation_started,
    result.evaluation_completed,
    result.overall_recommendation,
    result.requires_human_review ? 1 : 0,
    result.summary.pass_count,
    result.summary.partial_count,
    result.summary.fail_count,
    result.summary.requires_judgment_count,
    result.summary.tier1_count,
    result.summary.tier2_count,
    result.summary.tier3_count,
    result.summary.overall_coverage
  );
  submissionCreated = true;

  // Import assessments
  const insertAssessment = db.prepare(`
    INSERT INTO assessments (
      submission_id, csap_id, csap_text, section, sheet, item_number,
      ai_result, ai_confidence, discretion_tier, evidence_coverage,
      regulatory_authority, linked_policies, reviewer_notes, action_required,
      evidence_found, keywords_matched, sections_searched
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);

  const insertMany = db.transaction((assessments: AssessmentResult[]) => {
    for (const assessment of assessments) {
      insertAssessment.run(
        result.submission_id,
        assessment.csap_id,
        assessment.csap_text,
        assessment.section,
        assessment.sheet,
        assessment.item_number,
        assessment.result,
        assessment.confidence,
        assessment.discretion_tier,
        assessment.evidence_coverage,
        assessment.regulatory_authority,
        JSON.stringify(assessment.linked_policies),
        assessment.reviewer_notes,
        assessment.action_required,
        JSON.stringify(assessment.evidence_found),
        JSON.stringify(assessment.keywords_matched),
        assessment.sections_searched
      );
    }
    return assessments.length;
  });

  assessmentsImported = insertMany(result.assessments);

  return { submissionCreated, assessmentsImported };
}

/**
 * Import from existing output file without running engine
 */
async function importFromExistingOutput(): Promise<EvaluationResult> {
  const outputFiles = await findOutputFiles(OUTPUT_PATH, '');
  if (outputFiles.length === 0) {
    throw new Error('No evaluation output files found');
  }

  const resultPath = outputFiles[0];
  console.log('[Import] Reading from:', resultPath);
  const resultContent = await readFile(resultPath, 'utf-8');
  return JSON.parse(resultContent);
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const submissionId = formData.get('submissionId') as string;
    const siteId = formData.get('siteId') as string;
    const mode = formData.get('mode') as string || 'existing';
    const files = formData.getAll('files') as File[];

    if (!submissionId || !siteId) {
      return NextResponse.json(
        { success: false, error: 'Missing submissionId or siteId' },
        { status: 400 }
      );
    }

    let result: EvaluationResult;
    let uploadDir: string | null = null;

    try {
      if (mode === 'import') {
        // Import from existing output file (no engine run)
        result = await importFromExistingOutput();
      } else {
        // Run the engine
        let extractionPath = EXTRACTIONS_PATH;

        // If files were uploaded, save them to temp directory
        if (mode === 'upload' && files.length > 0) {
          uploadDir = await saveUploadedFiles(files);
          extractionPath = uploadDir;
        }

        result = await runEvaluationEngine(submissionId, extractionPath);
      }

      // Import results to database
      const importResult = await importResultsToDatabase(result);

      // Cleanup temp files if uploaded
      if (uploadDir) {
        await cleanupUploadDir(uploadDir);
      }

      return NextResponse.json({
        success: true,
        submissionId: result.submission_id,
        summary: {
          totalItems: result.total_checklist_items,
          passCount: result.summary.pass_count,
          failCount: result.summary.fail_count,
          partialCount: result.summary.partial_count,
          requiresJudgmentCount: result.summary.requires_judgment_count,
          overallCoverage: result.summary.overall_coverage,
        },
        importResult: {
          submissionCreated: importResult.submissionCreated,
          assessmentsImported: importResult.assessmentsImported,
        },
        outputPath: OUTPUT_PATH,
      });
    } catch (error) {
      // Cleanup temp files on error
      if (uploadDir) {
        await cleanupUploadDir(uploadDir);
      }
      throw error;
    }
  } catch (error) {
    console.error('Error running evaluation engine:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to run evaluation engine',
      },
      { status: 500 }
    );
  }
}
